# Solid

SOLID — это аббревиатура принципов, объектно-ориентированного дизайна. 

Впервые была описана Робертом Мартином. 

По сути любой из принципов сводится к правильному построению абстракций. 

В целом главная цель SOLID — это сделать код легко читаемым и понятным.

- S — SRP -(single responsobility) — Принцип разделения ответственности

- O — OCP — (open-closed) — Принцип открытости-закрытости

- L —  LSP — (Liskov) — Принцип подстановки Барбары Лисков

- I — ISP — (interface segregation) — Принцип разделения интерфейсов

- D — DIP- (dependency injection) — Принцип инверсии зависимостей

# S — Принцип разделения ответственности

Существует лишь одна причина, приводящая к изменению класса

«Сделайте одно и сделайте это хорошо», почти в яблочко. 

Каждая функция должна выполнять что-то одно.  

Для следования этому принципу можно использовать вот такую стратегию:

Для каждой созданной/создаваемой функции необходимо продумывать, есть ли полезная часть, которую можно извлечь в еще более маленькую функцию

```
/* 
BAD

class UserSettings {
  constructor(user) {
    this.user = user;
  }

  changeSettings(settings) {
    if (this.verifyCredentials()) {
      // ...
    }
  }

  verifyCredentials() {
    // ...
  }
}
*/

/* GOOD */
class UserAuth {
  constructor(user) {
    this.user = user;
  }

  verifyCredentials() {
    // ...
  }
}


class UserSettings {
  constructor(user) {
    this.user = user;
    this.auth = new UserAuth(user);
  }

  changeSettings(settings) {
    if (this.auth.verifyCredentials()) {
      // ...
    }
  }
}

```

# O — Принцип открытости-закрытости

«программные сущности должны быть открыты для расширения, но закрыты для модификации.»

Если коротко, то это означает, что написанный код должен иметь возможность расширяться без изменения существующего кода. 

В примере существует класс HttpRequester, который не позволяет создавать новые классы, наследуемые от Adapter. 

Диспетчеризация предусматривает только 2 варианта: ajaxAdapter и httpNodeAdapter.

```
/*
BAD

class AjaxAdapter extends Adapter {
  constructor() {
    super();
    this.name = 'ajaxAdapter';
  }
}

class NodeAdapter extends Adapter {
  constructor() {
    super();
    this.name = 'nodeAdapter';
  }
}

class HttpRequester {
  constructor(adapter) {
    this.adapter = adapter;
  }

  fetch(url) {
    if (this.adapter.name === 'ajaxAdapter') {
      return makeAjaxCall(url).then((response) => {
        // transform response and return
      });
    } else if (this.adapter.name === 'httpNodeAdapter') {
      return makeHttpCall(url).then((response) => {
        // transform response and return
      });
    }
  }
}

function makeAjaxCall(url) {
  // request and return promise
}

function makeHttpCall(url) {
  // request and return promise
}



*/

GOOD

class AjaxAdapter extends Adapter {
  constructor() {
    super();
    this.name = 'ajaxAdapter';
  }

  request(url) {
    // request and return promise
  }
}

class NodeAdapter extends Adapter {
  constructor() {
    super();
    this.name = 'nodeAdapter';
  }

  request(url) {
    // request and return promise
  }
}

class HttpRequester {
  constructor(adapter) {
    this.adapter = adapter;
  }

  fetch(url) {
    return this.adapter.request(url).then((response) => {
      // transform response and return
    });
  }
}

```

# L — Принцип подстановки Барбары Лисков

«объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.»

Подтип может расширять границы применимости, но система типов не может гарантировать корректность иерархии.  

Надо запомнить 2 тезиса:

- Предусловия не могут быть усилены в подклассе

- Постусловия не могут быть ослаблены в подклассе

Суть принципа подстановки в здравом смысле.


```
/*class Rectangle {
  constructor() {
    this.width = 0;
    this.height = 0;
  }

  setColor(color) {
    // ...
  }

  render(area) {
    // ...
  }

  setWidth(width) {
    this.width = width;
  }

  setHeight(height) {
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }
}

class Square extends Rectangle {
  setWidth(width) {
    this.width = width;
  }

  setHeight(height) {
    this.height = width;
  }
}

function renderLargeRectangles(rectangles) {
  rectangles.map(rectangle => {
    rectangle.setWidth(4);
    rectangle.setHeight(5);
    const area = rectangle.getArea(); // BAD: Returns 25 for Square. Should be 20.
    rectangle.render(area);
  });
}

const rectangles = [new Rectangle(), new Rectangle(), new Square()];
renderLargeRectangles(rectangles);
*/

class Shape {
  setColor(color) {
    // ...
  }

  render(area) {
    // ...
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }
}

class Square extends Shape {
  constructor(length) {
    super();
    this.length = length;
  }

  getArea() {
    return this.length * this.length;
  }
}

function renderLargeShapes(shapes) {
  shapes.map((shape) => {
    const area = shape.getArea();
    shape.render(area);
  });
}

const shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];
renderLargeShapes(shapes);

```

# I — Принцип разделения интерфейсов

«много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»

Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе.

BAD:

```

class DOMTraverser {
  constructor(settings) {
    this.settings = settings;
    this.setup();
  }

  setup() {
    this.rootNode = this.settings.rootNode;
    this.settings.animationModule.setup();
  }

  traverse() {
    // ...
  }
}

const $ = new DOMTraverser({
  rootNode: document.getElementsByTagName("body"),
  animationModule() {} // В большинстве случаев нам не нужно анимировать при перемещении.
  // ...
});

```
Good:

```

class DOMTraverser {
  constructor(settings) {
    this.settings = settings;
    this.options = settings.options;
    this.setup();
  }

  setup() {
    this.rootNode = this.settings.rootNode;
    this.setupOptions();
  }

  setupOptions() {
    if (this.options.animationModule) {
      // ...
    }
  }

  traverse() {
    // ...
  }
}

const $ = new DOMTraverser({
  rootNode: document.getElementsByTagName("body"),
  options: {
    animationModule() {}
  }
});

```


# D — Принцип инверсии зависимостей

«Зависимость на Абстракциях. Нет зависимости на что-то конкретное.»

Это означает, что модуль высокого уровня не должен зависеть от модуля низкого уровня. Только от абстракций.

BAD

```
class InventoryRequester {
  constructor() {
    this.REQ_METHODS = ["HTTP"];
  }

  requestItem(item) {
    // ...
  }
}

class InventoryTracker {
  constructor(items) {
    this.items = items;

    // BAD: Мы создали зависимость от конкретной реализации запроса.
    // Нам просто нужно, чтобы requestItems зависели от метода запроса: `request`
    this.requester = new InventoryRequester();
  }

  requestItems() {
    this.items.forEach(item => {
      this.requester.requestItem(item);
    });
  }
}

const inventoryTracker = new InventoryTracker(["apples", "bananas"]);
inventoryTracker.requestItems();

```

GOOD

```
class InventoryTracker {
  constructor(items, requester) {
    this.items = items;
    this.requester = requester;
  }

  requestItems() {
    this.items.forEach(item => {
      this.requester.requestItem(item);
    });
  }
}

class InventoryRequesterV1 {
  constructor() {
    this.REQ_METHODS = ["HTTP"];
  }

  requestItem(item) {
    // ...
  }
}

class InventoryRequesterV2 {
  constructor() {
    this.REQ_METHODS = ["WS"];
  }

  requestItem(item) {
    // ...
  }
}

// Создавая наши зависимости извне и внедряя их, мы можем легко
// заменяем наш модуль запроса на новый модный, использующий WebSockets.
const inventoryTracker = new InventoryTracker(
  ["apples", "bananas"],
  new InventoryRequesterV2()
);
inventoryTracker.requestItems();

```
