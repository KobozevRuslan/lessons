# Навигация по DOM-элементам

# Дети: childNodes, firstChild, lastChild

- Дочерние узлы (или дети) – элементы, которые являются непосредственными детьми узла. 

Другими словами, элементы, которые лежат непосредственно внутри данного. 

Например, <head> и <body> являются детьми элемента <html>.
    
- Потомки – все элементы, которые лежат внутри данного, включая детей, их детей и т.д.

В примере ниже детьми тега <body> являются теги <div> и <ul> (и несколько пустых текстовых узлов):
    
```
<html>
<body>
  <div>Начало</div>

  <ul>
    <li>
      <b>Информация</b>
    </li>
  </ul>
</body>
</html>

```
А потомки <body> – это и прямые дети <div>, <ul> и вложенные в них: <li> (потомок <ul>) и <b> (потомок <li>) – в общем, все элементы поддерева.

# childNodes

Коллекция childNodes содержит список всех детей, включая текстовые узлы.

Пример ниже последовательно выведет детей document.body:

```
<html>
<body>
  <div>Начало</div>

  <ul>
    <li>Информация</li>
  </ul>

  <div>Конец</div>

  <script>
    for (let i = 0; i < document.body.childNodes.length; i++) {
      alert( document.body.childNodes[i] ); // Text, DIV, Text, UL, ..., SCRIPT
    }
  </script>
  ...какой-то HTML-код...
</body>
</html>

```

Свойства **firstChild** и **lastChild** обеспечивают быстрый доступ к первому и последнему дочернему элементу.

Они, по сути, являются всего лишь сокращениями. Если у тега есть дочерние узлы, условие ниже всегда верно:

```
elem.childNodes[0] === elem.firstChild
elem.childNodes[elem.childNodes.length - 1] === elem.lastChild

```

# DOM-коллекции – только для чтения

DOM-коллекции, и даже более – все навигационные свойства, перечисленные в этой главе, доступны только для чтения.

Мы не можем заменить один дочерний узел на другой, просто написав childNodes[i] = ....

# DOM-коллекции живые

Почти все DOM-коллекции, за небольшим исключением, живые. Другими словами, они отражают текущее состояние DOM.

Если мы сохраним ссылку на elem.childNodes и добавим/удалим узлы в DOM, то они появятся в сохранённой коллекции автоматически.

# Соседи и родитель

Соседи – это узлы, у которых один и тот же родитель.

Следующий узел того же родителя (следующий сосед) – **в свойстве nextSibling**, **а предыдущий – в previousSibling**.

Родитель доступен через parentNode.

```
// родителем <body> является <html>
alert( document.body.parentNode === document.documentElement ); // выведет true

// после <head> идёт <body>
alert( document.head.nextSibling ); // HTMLBodyElement

// перед <body> находится <head>
alert( document.body.previousSibling ); // HTMLHeadElement

```

# Навигация только по элементам

- children – коллекция детей, которые являются элементами.

- firstElementChild, lastElementChild – первый и последний дочерний элемент.

- previousElementSibling, nextElementSibling – соседи-элементы.

- parentElement – родитель-элемент.


# Promise. Понимание промисов

Промис - это объект, у которого есть 3 состояния:

- Panding - ожидание

- Resolve - выполнено успешно

- Reject - выполнено с ошибкой

```
let promise = new Promise(function(resolve, reject) {
  // функция-исполнитель (executor)
  // "певец"
});

```

Функция, переданная в конструкцию new Promise, **называется исполнитель (executor)**. 

Когда Promise создаётся, она запускается автоматически. 

Она должна содержать «создающий» код, который когда-нибудь создаст результат. 

Её аргументы resolve и reject – это колбэки, которые предоставляет сам JavaScrip

Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:

- resolve(value) — если работа завершилась успешно, с результатом value.

- reject(error) — если произошла ошибка, error – объект ошибки.

Итак, исполнитель запускается автоматически, он должен выполнить работу, а затем вызвать resolve или reject.

Ниже пример конструктора Promise и простого исполнителя с кодом, дающим результат с задержкой (через setTimeout):

```
let promise = new Promise(function(resolve, reject) {
  // эта функция выполнится автоматически, при вызове new Promise

  // через 1 секунду сигнализировать, что задача выполнена с результатом "done"
  setTimeout(() => resolve("done"), 1000);
});

```

Мы можем наблюдать две вещи, запустив код выше:

- Функция-исполнитель запускается сразу же при вызове new Promise.

- Исполнитель получает два аргумента: resolve и reject — это функции, встроенные в JavaScript, поэтому нам не нужно их писать. Нам нужно лишь позаботиться, чтобы исполнитель вызвал одну из них по готовности.

Спустя одну секунду «обработки» исполнитель вызовет resolve("done"), чтобы передать результат:

https://learn.javascript.ru/article/promise-basics/promise-resolve-1.svg

Hemoweork8: 

0) ! Учить теорию ! 

1) Реализовать Числа Фибоначчи двумя способами (рекурсия и цикл)

2) Рассчитать сумму натуральных чисел до n (2 решения - рекурсия и цикл)

3) Напишите функцию printNumbers(from, to), которая выводит число каждую секунду, начиная от from и заканчивая to.

Сделайте два варианта решения.

- Используя setInterval.

- Используя рекурсивный setTimeout.

4) Нужно создать интервал, который выводит в консоль количество секунд, прошедших с момента запуска программы.

"Прошло: 1 сек."

"Прошло: 2 сек." ..... и так далее

Допишите программу так, чтобы она останавливалась при достижении 5 секунд и надпись о пройденном времени больше не выводилась в консоль.

5) В html есть такое

```
<ul id='ulList'>
    <li class="li">How are you?</li>
    <li class="li">1</li>
    <li class="li">2</li>
    <li class="li">3</li>
    <li class="li">3</li>
    <li class="li">Hello</li>
</ul>
<button id='sum'>Get Sum</button>
<input type="text" id="inp">

```

Написать логику, которая будет находить сумму всех **ЧИСЕЛ**, которые вписаны в li, и выводить эту сумму (в формате 1 + 2 + 3 = 6) в инпут (#inp) по нажатию на кнопку (#sum)

Вот так должно быть:

https://prnt.sc/y5v875

6) Написать игру "крестики-нолики" )

Игра должна быть на двоих. 

Должно быть вот так:

https://prnt.sc/y6p58p

Эта домашка будет на 2 занятия. За это будет отдельная оценка.



