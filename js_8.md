# Прекращение всплытия событий

Всплытие идёт с «целевого» элемента прямо наверх. 

По умолчанию событие будет всплывать до элемента <html>, а затем до объекта document, а иногда даже до window, вызывая все обработчики на своём пути.

Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие.

Для этого нужно вызвать метод event.stopPropagation().

Например, здесь при клике на кнопку <button> обработчик body.onclick не сработает:

```
<body onclick="alert(`сюда всплытие не дойдёт`)">
  <button onclick="event.stopPropagation()">Кликни меня</button>
</body>

```


# event.stopImmediatePropagation()

Для того, чтобы полностью остановить обработку, существует метод event.stopImmediatePropagation(). 

Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.


# Планирование: setTimeout и setInterval

Мы можем вызвать функцию не в данный момент, а позже, через заданный интервал времени. Это называется «планирование вызова».

Для этого существуют два метода:

- setTimeout позволяет вызвать функцию один раз через определённый интервал времени.
- setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.

# setTimeout

```
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)

```

Параметры: 

- func|code

Функция или строка кода для выполнения. Обычно это функция. По историческим причинам можно передать и строку кода, но это не рекомендуется.

- delay

Задержка перед запуском в миллисекундах (1000 мс = 1 с). Значение по умолчанию – 0.

- arg1, arg2…

Аргументы, передаваемые в функцию (не поддерживается в IE9-)

Например, данный код вызывает sayHi() спустя одну секунду:

```
function sayHi() {
  alert('Привет');
}

setTimeout(sayHi, 1000);

```

```
function sayHi(phrase, who) {
  alert( phrase + ', ' + who );
}

setTimeout(sayHi, 1000, "Привет", "Джон"); // Привет, Джон

```

Если первый аргумент является строкой, то JavaScript создаст из неё функцию.

Это также будет работать:

```
setTimeout("alert('Привет')", 1000);

```

# Отмена через clearTimeout

Вызов setTimeout возвращает «идентификатор таймера» timerId, который можно использовать для отмены дальнейшего выполнения.

Синтаксис для отмены:

```
let timerId = setTimeout(...);
clearTimeout(timerId);

```

# setInterval

Метод setInterval имеет такой же синтаксис как setTimeout:

```
let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)

```

Все аргументы имеют такое же значение. 

Но отличие этого метода от setTimeout в том, что функция запускается не один раз, а периодически через указанный интервал времени.

```
// повторить с интервалом 2 секунды
let timerId = setInterval(() => alert('tick'), 2000);

// остановить вывод через 5 секунд
setTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);

```

# Рекурсивный setTimeout

Есть два способа запускать что-то регулярно.

Один из них setInterval. Другим является рекурсивный setTimeout. Например:

```
/** вместо:
let timerId = setInterval(() => alert('tick'), 2000);
*/

let timerId = setTimeout(function tick() {
  alert('tick');
  timerId = setTimeout(tick, 2000); // (*)
}, 2000);

```

# Замыкание

Что такое замыкание?

Замыкание это функция у которой есть доступ к своей внешней функции по области видимости, даже после того, как внешняя функция прекратилась.

Замыкание это функция, захватывающая лексическое окружение того контекста, где она создана.

# Что такое лексическая область видимости?

Лексическая область видимости это статическая область в JavaScript, имеющая прямое отношение к доступу к переменным, функциям и объектам, основываясь на их расположении в коде. 

Вот пример:

```
let a = 'global';
function outer() {
    let b = 'outer';
function inner() {
      let c = 'inner'
      console.log(c);   // выдаст 'inner'
      console.log(b);   // выдаст 'outer'
      console.log(a);   // выдаст 'global'
    }
    console.log(a);     // выдаст 'global'
    console.log(b);     // выдаст 'outer'
    inner();
  }
outer();
console.log(a);         // выдаст 'global'

```

В общем, цепочка области видимости выше будет такой:

```
Global {
  outer {
    inner
  }
}

```

# Практические примеры замыкания

```
function person() {
  let name = 'Peter';
  
  return function displayName() {
    console.log(name);
  };
}
let peter = person();
peter(); // выведет 'Peter'

```

```
function getCounter() {
  let counter = 0;
  return function() {
    return counter++;
  }
}
let count = getCounter();
console.log(count());  // 0
console.log(count());  // 1
console.log(count());  // 2

```

# Как работают замыкания?

Чтобы реально это понять, нам надо разобраться в двумя самыми важными концепциями в JavaScript, а именно, 

1) Контекст выполнения

2) Лексическое окружение.

# Контекст выполнения

Это абстрактная среда, в которой JavaScript код оценивается и выполняется. 

Когда выполняется “глобальный” код, он выполняется внутри глобального контекста выполнения, а код функции выполняется внутри контекста выполнения функции.

Тут может быть только один запущенный контекст выполнения (JavaScript это однопоточный язык), который управляется стеком запросов.

Стек выполнения это стек с принципом LIFO (Последний вошёл, первый вышел), в котором элементы могут быть добавлены или удалены только сверху стека.

Давайте посмотрим на пример кода, чтобы лучше понять контекст выполнения и стек:


![help](https://miro.medium.com/max/700/1*huMb5-_MmM8zkFVnchsjbg.png)


Во время выполнения этого кода, движок JavaScript создаёт глобальный контекст вызова, для того, чтобы выполнить глобальный код и когда он доходит до вызова функции first(), он создаёт новый контекст выполнения для этой функции и ставит её на вершину стека вызовов.

Так что он будет выглядеть таким образом для кода выше:


![help](https://miro.medium.com/max/700/1*sOyjVHh8h49PThAVs7PS6w.png)

У лексического окружения есть два компонента: 

(1) запись в окружении 

(2) отсылка к внешнему окружению.

1) Запись в окружении(environment record) это место хранятся объявления переменной или функции.

2) Отсылка к внешнему окружению (reference to the outer environment) означает то, что у него есть доступ к внешнему (родительскому) лексическому окружению. 

Этот компонент самый важный для понимания того, как работают замыкания.

```
lexicalEnvironment = {
  environmentRecord: {
    <identifier> : <value>,
    <identifier> : <value>
  }
  outer: < Reference to the parent lexical environment>
}

```

Пример: 

```
let a = 'Hello World!';
function first() {
  let b = 25;  
  console.log('Inside first function');
}
first();
console.log('Inside global execution context');

```

```
globalLexicalEnvironment = {
  environmentRecord: {
      a     : 'Hello World!',
      first : < reference to function object >
  }
  outer: null
}

```


HomeWork 7:

**pure JS**

1 ) Создайте элемент 'p', при клике на котором появляется картинка размером 100px

При наведении указателя мышки на картинку ее размер должен плавно увеличиваться до 200px

При клике на картинке она должна исчезать

2) Дан массив с числами. 

Найдите сумму последних N элементов до первого нуля с конца. 

Пример: [1, 2, 3, 0, 4, 5, 6] - суммируем последние 3 элемента, так как дальше стоит элемент с числом 0.

3) Дан массив с числами. Узнайте сколько элементов с начала массива надо сложить, чтобы в сумме получилось больше 10-ти.

4) Есть инпут, в который что-то вводим. Рядом с инпутом есть кнопка. По нажатию на кнопку выводим в консоль то, что вписали в инпут.

5) Привяжите всем ссылкам в документе событие - по наведению на ссылку в конец ее текста дописывается ее href в круглых скобках.

HTML: 

```
<div>
    <a href="https://www.google.com/" title="">Текст первой ссылки</a>
</div>
<div>
    <a href="https://www.apple.com/" title="">Текст второй ссылки</a>
</div>
<div>
    <a href="https://www.youtube.com/" title="">Текст третьей ссылки</a>
</div>

```

6) Добавьте JavaScript к кнопке button, чтобы при нажатии элемент <div id="text"> исчезал.
 
 Как должно быть:
 
 https://prnt.sc/xu2l8p
 

7) Сделать то, что на скрине

https://prnt.sc/xu1x8n

**не используем type='number' для инпута**

Логика:

- Сделать валидацию для инпута. Нужно проверять то, что вводим в инпут. Вводить можно только тип данных number. Если юзер ввел букву, то удаляем все (все что ввели) в инпуте

- В инпут юзер вводит кол-во пикселей, на которое хотим передвинуть круг (по Х координате)

- При нажатии на кнопку START получаем данные из инпута (какое-то число) и передвигаем наш круг на то кол-во пикселей, которое ввел юзер в инпут

- Передвижения круга должно быть с анимацией

- Если юзер ввел число больше 600px || меньше нуля, то напрямую пишем в инпут ERROR (понимаем это после нажатия на кнопку)
