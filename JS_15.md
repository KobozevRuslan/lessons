# Генераторы

Обычные функции возвращают только одно-единственное значение (или ничего).

Генераторы могут порождать (yield) множество значений одно за другим, по мере необходимости.

# Функция-генератор

Для объявления генератора используется специальная синтаксическая конструкция: function*, которая называется «функция-генератор».

Выглядит она так:

```
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}

```

Функции-генераторы ведут себя не так, как обычные. Когда такая функция вызвана, она не выполняет свой код. Вместо этого она возвращает специальный объект, так называемый «генератор», для управления её выполнением.

Вот, посмотрите:

```
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}

// "функция-генератор" создаёт объект "генератор"
let generator = generateSequence();
alert(generator); // [object Generator]

```

Выполнение кода функции ещё не началось:

# Начнём с рассмотрения одного генератора:

```
function* quips(name) {
  yield "привет, " + name + "!";
  yield "я надеюсь, вам нравятся статьи";
  if (name) {
    yield `как круто, что ваше имя - ${name}`;
  }
  yield "увидимся!";
}

```

Внутри функции-генератора есть ключевое слово yield с синтаксисом, похожим на return. 

Отличие в том, что функция (в том числе функция-генератор) может вернуть значение только один раз, но отдать значение функция-генератор может любое количество раз. 

Выражение yield приостанавливает выполнение генератора, так что его можно позже возобновить.

# Что делают генераторы

Что произойдёт, если запустить функцию-генератор quips()?

```
var iter = quips("jorendorff");
  // [object Generator]
iter.next()
  // { value: "привет, jorendorff!", done: false }
iter.next()
  // { value: "я надеюсь, вам нравятся статьи", done: false }
iter.next()
  // { value: "увидимся!", done: false }
iter.next()
  // { value: undefined, done: true }

```

Каждый раз, как вы вызываете метод .next() у объекта Generator, вызов функции оттаивает и выполняется, пока не достигнет следующего выражения yield.

При последнем вызове iter.next() мы, наконец, достигли конца функции-генератора, так что поле .done результата стало равно true. 

Добраться до конца функции — это всё равно что вернуть undefined, и именно поэтому поле .value результата равно undefined.


# Результатом метода next() всегда является объект с двумя свойствами:

- value: значение из yield.

- done: true, если выполнение функции завершено, иначе false.

Например, здесь мы создаём генератор и получаем первое из возвращаемых им значений:

```
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}

let generator = generateSequence();

let one = generator.next();

alert(JSON.stringify(one)); // {value: 1, done: false}

```

На данный момент мы получили только первое значение, выполнение функции остановлено на второй строке:

![help](https://learn.javascript.ru/article/generators/generateSequence-2.svg)
