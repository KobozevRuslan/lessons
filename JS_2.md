# JS Lesson 2

Преобразование типов

* Строковое преобразование
* Численное преобразование
* Логическое преобразование



# Строковое преобразование
Для того чтобы явно преобразовать значение в строку, можно воспользоваться функцией **String()**. 

Неявное преобразование вызывает использование обычного оператора сложения, +, с двумя операндами, если один из них является строкой:

```

String(123) // явное преобразование
123 + ''    // неявное преобразование

```

Все примитивные типы преобразуются в строки вполне естественным и ожидаемым образом:

```

String(123)    // '123'
String(-12.3)  // '-12.3'
String(null)   // 'null'
String(undefined)  // 'undefined'
String(true)   // 'true'
String(false)  // 'false'

```

В случае с типом **Symbol** дело несколько усложняется, так как значения этого типа можно преобразовать к строковому типу только явно.

```

String(Symbol('my symbol'))   // 'Symbol(my symbol)'
'' + Symbol('my symbol')      // ошибка TypeError

```

Что будет?

```

let a = 1 + ''; // a === ?

let b = 2 + 'hello'; // b === ?

let c = typeof(String(12) + 1); // c === ?

let d = 12 + '1'; // d === ? 

```


# Преобразование к типу Boolean

Для того, чтобы явно преобразовать значение к логическому типу, используют функцию **Boolean()**. 

Неявное преобразование происходит в логическом контексте, или вызывается логическими операторами **(|| && !)**.

```

Boolean(2)          // явное преобразование
if (2) { ... }      // неявное преобразование в логическом контексте
!!2                 // неявное преобразование логическим оператором
2 || 'hello'        // неявное преобразование логическим оператором

```

Обратите внимание на то, что операторы, вроде || и && выполняют преобразование значений к логическому типу для внутренних целей, а возвращают значения исходных операндов, даже если они не являются логическими.

```

// это выражение возвращает число 123, а не true
// 'hello' и 123 неявно преобразуются к логическому типу при работе оператора && для вычисления значения выражения
let x = 'hello' && 123;   // x === 123

```

Так как при приведении значения к логическому типу возможны лишь два результата — **true** или **false**, легче всего освоить этот вид преобразований, запомнив те выражения, которые выдают **false**:

```

Boolean('')           // false
Boolean(0)            // false     
Boolean(-0)           // false
Boolean(NaN)          // false
Boolean(null)         // false
Boolean(undefined)    // false
Boolean(false)        // false

```

# Преобразование к типу Number

Явное преобразование к числовому типу выполняется с помощью функции **Number()** — то есть по тому же принципу, который используется для типов **Boolean** и **String**.

Неявное приведение значения к типу Number выполняют следующие операторы:

- Операторы сравнения **(>, <, <=, >=)**.
- Побитовые операторы **(|, &, ^, ~)**.
- Арифметические операторы **(-, +, *, /, %)**. Обратите внимание на то, что оператор + с двумя операндами не вызывает неявное преобразование к числовому типу, если хотя бы один оператор является строкой.
- Унарный оператор **+**.
- Оператор нестрогого равенства **==** **(а также !=)**. Обратите внимание на то, что оператор == не производит неявного преобразования в число, если оба операнда являются строками.

```

Number('123')   // явное преобразование
+'123'          // неявное преобразование
123 != '456'    // неявное преобразование
4 > '5'         // неявное преобразование
5/null          // неявное преобразование
true | 0        // неявное преобразование

```

Вот как в числа преобразуются примитивные значения:

```
Number(null)         // 0
Number(undefined)    // NaN
Number(true)         // 1
Number(false)        // 0
Number(" 12 ")       // 12
Number("-12.34")     // -12.34
Number("\n")         // 0
Number(" 12s ")      // NaN
Number(123)          // 123

```

Значения типа Symbol не могут быть преобразованы в число ни явно, ни неявно

```
Number(Symbol('my symbol'))    // Ошибка TypeError
+Symbol('123')                 // Ошибка TypeError

```

Вот правила, которые стоит запомнить:

```

null == 0               // false, null не преобразуется в 0
null == null            // true
null === null           // true

undefined == undefined  // true
undefined === undefined  // true

null == undefined       // true
null === undefined      // false

```

# Преобразование типов для объектов

Самое простое — это преобразование в логическое значение: любое значение, не являющееся примитивом, всегда true

```
const person = {
 name: 'Vlad'
};

Boolean(person); // true

const obj = {};
Boolean(obj); // true

```

Но что будет, если я приведу object к строке?

```
let a = {};
console.log(a + ''); // [object Object]

```

А если к числу?

```
const b = {};
console.log(b + 1); // [object Object]1
```

Для этого есть стандартные методы js - **toString()** и **valueOf()** :


```
let person = {
 name: 'Vlad',
 toString: function () {
   return 'Hello World!'
 },
 valueOf: function () {
   return 1
 }
};

String(person); // 'Hello World!'
person + 1; // 2
person + ''; // '1'

```

!!! Обратите внимание на то, что person + '' возвращает ‘1’ в виде строки. Оператор **+** вызывает стандартный режим преобразования. Как уже было сказано, Object рассматривает приведение к числу как преобразование по умолчанию, поэтому использует сначала метод valueOf() а не toString().


# Примеры

```
true + false             // 1
12 / "6"                 // 2
"number" + 15 + 3        // 'number153'
15 + 3 + "number"        // '18number'
[1] > null               // true
"foo" + + "bar"          // 'fooNaN'
'true' == true           // false
false == 'false'         // false
null == ''               // false
!!"false" == !!"true"    // true
['x'] == 'x'             // true 
[] + null + 1            // 'null1'
[1,2,3] == [1,2,3]       // false

```

![help](https://a.d-cd.net/SYAAAgKXiOA-960.jpg)




# Тип BigInt

BigInt – это специальный числовой тип, который предоставляет возможность работать с целыми числами произвольной длины.

Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала или вызвать функцию BigInt()

```
const bigint = 1234567890123456789012345678901234567890n;

const sameBigint = BigInt("1234567890123456789012345678901234567890");

const bigintFromNumber = BigInt(10); // то же самое, что и 10n

```


BigInt можно использовать как обычные числа, к примеру:

```
console.log(1n + 2n); // 3

console.log(5n / 2n); // 2

```

Но в математических операциях мы не можем смешивать bigint и обычные числа:

```
alert(1n + 2); // Error: Cannot mix BigInt and other types

```


# Функции (function)

В JavaScript функция является особым типом объекта, который позволяет закладывать и применять определенную логику для обработки данных.

**Синтааксис**

```
function наименование_функции(аргумент_1, аргумент_2, ..., аргумент_N){
  тело_функции
}

```

Вызов функции JavaScript осуществляется по ее имени, за которым следуют круглые скобки с аргументами (если они имеются)

Именно круглые скобки говорят, что функцию необходимо выполнить.

```
function sayHello() {
  console.log('Hello World');
}

sayHello(); // в консоли будет Hello World

```

- Давайте напишем функцию, которая будет выводить сумму чисел 1 и 5 в консоль


Рассмотрим пример c аргументами:

```
function sayHello(name) {
 console.log('Hello, ' + name);
}

sayHello('Vlad'); // в консоли будет Hello, Vlad

```

- name - аргумент функции sayHello



